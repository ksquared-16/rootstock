const { expect } = require('chai');
const { ethers } = require('hardhat');

describe('Exploit-OMP002', () => {
  let deployer;
  let attacker;
  let lunaToken;
  let oneMilPixels;
  const lunaInitSupply = 10000000;
  const pixelId = 1001;
  const pixelColor = '0xffff0a';
  const realTokenAmount = 1;
  const fakeTokenAmount = 100;

  // deploy smart contracts
  before(async () => {
    [deployer, attacker] = await ethers.getSigners();
    const LunaToken = await ethers.getContractFactory('LunaToken');
    lunaToken = await LunaToken.connect(deployer).deploy(lunaInitSupply);
    await lunaToken.deployed();
    const OneMilPixels = await ethers.getContractFactory('OneMilNftPixels');
    oneMilPixels = await OneMilPixels.connect(deployer).deploy(
      lunaToken.address,
    );
    await oneMilPixels.deployed();
  });

  // give 1 token to attacker
  it('attacker should have 1 Luna token at his balance', async () => {
    await lunaToken.transfer(attacker.address, 1).then((tx) => tx.wait());
    expect(await lunaToken.balanceOf(attacker.address)).to.equal(1);
  });

  // exploit
  it('attacker is not able to assemble fake calldata to buy pixel for low price', async () => {
    const sigHash = oneMilPixels.interface.getSighash('buy');
    const callData = ethers.utils.defaultAbiCoder.encode(
      ['bytes4', 'address', 'uint24', 'bytes3', 'uint256'],
      [sigHash, attacker.address, pixelId, pixelColor, fakeTokenAmount],
    );
    const transferAndCall = 'transferAndCall(address,uint256,bytes)';
    const tx = lunaToken[transferAndCall](
      oneMilPixels.address,
      realTokenAmount,
      callData,
    );
    await expect(tx).to.be.revertedWith('Fake amount exceeds actual amount transferred');
  });

  it('the pixel should remain unowned after exploit attempt', async () => {
    await expect(oneMilPixels.ownerOf(pixelId)).to.be.revertedWith(
      'ERC721: invalid token ID',
    );
  });
});