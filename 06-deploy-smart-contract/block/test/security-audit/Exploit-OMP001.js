const { expect } = require('chai');
const { ethers } = require('hardhat');

describe('Exploit-OMP001', () => {
  let deployer;
  let attacker;
  let lunaToken;
  let oneMilPixels;
  let exploit;
  const lunaInitSupply = 10000000;
  const oneMlnPixLunaSupply = 900;
  const exploitLunaSupply = 100;

  before(async () => {
    [deployer, attacker] = await ethers.getSigners();
    const LunaToken = await ethers.getContractFactory('LunaToken');
    lunaToken = await LunaToken.connect(deployer).deploy(lunaInitSupply);
    await lunaToken.deployed();
    const OneMilPixels = await ethers.getContractFactory('OneMilNftPixels');
    oneMilPixels = await OneMilPixels.connect(deployer).deploy(
      lunaToken.address,
    );
    await oneMilPixels.deployed();
    // Comments from the Security Audit Proof of Concept
    // This exploit occurs via a deployed SC, which can be found here:
    // /contracts/security-audit/Exploit-OMP001.sol
    const Exploit = await ethers.getContractFactory('ExploitOMP001');
    // Note that while deploying the contract, constructor expects two arguments: LunaToken contract address and OneMilNftPixels contract address respectively.
    exploit = await Exploit.connect(attacker).deploy(
      lunaToken.address,
      oneMilPixels.address,
    );
    await exploit.deployed();
  });

  // Transfer LunaTokens (50 should be enough) to the Exploit contract so that it has sufficient balance to purchase NFTs.
  it('transfer some lunas to exploit', async () => {
    const tx = await lunaToken.transfer(exploit.address, exploitLunaSupply);
    await tx.wait();
    expect(await lunaToken.balanceOf(exploit.address)).to.equal(
      exploitLunaSupply,
    );
  });

  // Make sure OneMilNftPixels contract has LunaTokens.
  it('transfer some lunas to oneMlnPix', async () => {
    const tx = await lunaToken.transfer(
      oneMilPixels.address,
      oneMlnPixLunaSupply,
    );
    await tx.wait();
    expect(await lunaToken.balanceOf(oneMilPixels.address)).to.equal(
      oneMlnPixLunaSupply,
    );
  });

  // Call the exploit function from the Exploit contract
  it('should not exploit reentrancy in withdrawCompensation()', async () => {
    const pixelId = 1335;
    const color = '0x343434';
    const amount = 20;
    const tx = exploit
      .connect(attacker)
      .exploit(pixelId, color, exploit.address, amount);
    await expect(tx).to.be.reverted;
  });

  // Check OneMilNftPixels contract’s LunaToken balance has not been stolen
  it('calling exploit() on Exploit should not withdraw (almost) all Lunas from oneMlnPix', async () => {
    const oneMnlBalance = await lunaToken.balanceOf(oneMilPixels.address);
    // big number <= 5
    expect(oneMnlBalance.lte(5)).to.be.false;
  });

  // Check Exploit contract’s LunaToken balance and confirm that it doesn't contain the balance stolen from OneMilNftPixels
  it('Exploit balance should not increase after the exploit attempt', async () => {
    const exploitBalance = await lunaToken.balanceOf(exploit.address);
    expect(exploitBalance).to.equal(exploitLunaSupply);
  });
});
