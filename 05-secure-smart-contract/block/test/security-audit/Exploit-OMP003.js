const { expect } = require('chai');
const { ethers } = require('hardhat');

async function deployContract(contractName, ...params) {
  const contractFactory = await ethers.getContractFactory(contractName);
  const smartContract = await contractFactory.deploy(...params);
  await smartContract.deployed();
  return smartContract;
}

describe('Exploit-OMP003', () => {
  let deployer;
  let buyer;
  let attacker;
  let lunaToken;
  let oneMilNftPixels;
  let buySigHash;
  let exploit;

  const pixel1001Id = 1001;
  const pixelDefaultColour = '0xff00ff';
  const tokensTotalSupply = 1e7;
  const compensationAmount = 10; // Luna tokens

  async function callFunction(
    selector,
    caller,
    ownerAddress,
    id,
    colour,
    price,
  ) {
    const transferAndCallSignature = 'transferAndCall(address,uint256,bytes)';
    const sigHash = oneMilNftPixels.interface.getSighash(selector);
    const callData = ethers.utils.defaultAbiCoder.encode(
      ['bytes4', 'address', 'uint24', 'bytes3', 'uint256'],
      [sigHash, ownerAddress, id, colour, price],
    );
    return lunaToken
      .connect(caller)
      [transferAndCallSignature](oneMilNftPixels.address, price, callData);
  }

  before(async () => {
    [deployer, buyer, attacker] = await ethers.getSigners();
    lunaToken = await deployContract('LunaToken', tokensTotalSupply);
    oneMilNftPixels = await deployContract(
      'OneMilNftPixels',
      lunaToken.address,
    );
    buySigHash = oneMilNftPixels.interface.getSighash('buy');
    // This exploit occurs via a deployed SC, which can be found here:
    // /contracts/security-audit/Exploit-OMP003.sol
    const Exploit = await ethers.getContractFactory('ExploitOMP003');
    exploit = await Exploit.connect(attacker).deploy(lunaToken.address);
    // give some Lunas to another account
    await lunaToken.transfer(buyer.address, 20).then((res) => res.wait());
    // give 1 Luna to attacker
    await lunaToken.transfer(attacker.address, 1).then((res) => res.wait());
  });

  it('Deployer buys pixel 1001', async () => {
    const tokenAmount = 10;
    await expect(
      callFunction(
        buySigHash,
        deployer,
        deployer.address,
        pixel1001Id,
        pixelDefaultColour,
        tokenAmount,
      ),
    )
      .to.emit(oneMilNftPixels, 'Transfer')
      .withArgs(ethers.constants.AddressZero, deployer.address, pixel1001Id);
  });

  it('Someone else rebuys the pixel and accidentally sets Luna token as the owner', async () => {
    const tokenAmount = 20;
    await expect(
      callFunction(
        buySigHash,
        buyer,
        // Luna token is now the pixel owner
        lunaToken.address,
        pixel1001Id,
        pixelDefaultColour,
        tokenAmount,
      ),
    )
      .to.emit(oneMilNftPixels, 'Transfer')
      .withArgs(deployer.address, lunaToken.address, pixel1001Id);
  });

  it('Deployer buys the pixel back', async () => {
    const tokenAmount = 30;
    await expect(
      callFunction(
        buySigHash,
        deployer,
        deployer.address,
        pixel1001Id,
        pixelDefaultColour,
        tokenAmount,
      ),
    )
      .to.emit(oneMilNftPixels, 'Transfer')
      .withArgs(lunaToken.address, deployer.address, pixel1001Id);
  });

  it('Luna token address receives a compensation', async () => {
    const compensation = await oneMilNftPixels.compensationBalances(
      lunaToken.address,
    );
    expect(compensation).to.equal(compensationAmount);
  });

  it(`attacker should not be able to call withdrawCompensation through transferAndCall and thus withdraw Luna's compensation`, async () => {
    const tokenAmount = 1;
    const withdrawSigHash = oneMilNftPixels.interface.getSighash(
      'withdrawCompensation',
    );
    await expect(
      callFunction(
        withdrawSigHash,
        attacker,
        exploit.address,
        pixel1001Id,
        pixelDefaultColour,
        tokenAmount,
      ),
    ).to.be.revertedWith('Call of an unknown function');
  });
});
